# 原理题02

## 13. vue为什么需要虚拟dom

Virtual DOM 就是js对象用来描述真实DOM，是对真实DOM的抽象

直接操作DOM性能低，js执行效率高，通过对虚拟DOM执行diff算法，减少DOM操作，提高性能

虚拟DOM支持跨平台，可以在不同的平台上运行，比如web、移动端、微信小程序等
  
render性能比用template, 但是在cli中编译时会将template转化为render，所以最终性能差距不大

## 14. vue中diff算法原理

Vue的diff算法是平级比较，采用深度递归+双指针的方式，逐层比较，如果不同，则更新DOM

1. 先比较是否是相同节点 key tag
2. 如果是相同节点，复用老节点，则比较属性是否相同
3. 比较儿子节点， 考虑老节点和新节点儿子
4. 比较优化：头头 尾尾 头尾 尾头
5. 比较查询复用

```js
function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) { /// vnode未传卸载组件
        if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
        return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    if (isUndef(oldVnode)) { /// 组件挂载，组件初始化时会执行此方法
        isInitialPatch = true
        createElm(vnode, insertedVnodeQueue)
    } else {
        const isRealElement = isDef(oldVnode.nodeType)
        if (!isRealElement && sameVnode(oldVnode, vnode)) { // 不是真实节点，并且属于相同节点
            // diff处理
            patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
        } else {
            // ...
        }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
}
```

执行到pacthVnode

```js
  function patchVnode(
      oldVnode,
      vnode,
      insertedVnodeQueue,
      ownerArray,
      index,
      removeOnly
  ) {
      // ...
      // 静态节点过滤
      if (isTrue(vnode.isStatic) &&
          isTrue(oldVnode.isStatic) &&
          vnode.key === oldVnode.key &&
          (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
      ) {
          vnode.componentInstance = oldVnode.componentInstance
          return
      }

      // ...
      if (isUndef(vnode.text)) {
          if (isDef(oldCh) && isDef(ch)) {
              // updateChildren子节点diff处理
              if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
          } else if (isDef(ch)) {
              // ...
              // 其他情形处理
          }
      }
```

## 15 既然vue通过数据劫持可以精准探测数据变化，为什么还要diff

给每一个属性增加一个watcher用于更新，会产生大量的watcher造成性能下降

而且过于细粒度的监听，不能保证页面更新精准

应此vue2则对组件用一个watcher进行渲染管理，通过diff比较进行组件更新

## 16 说明key的作用和原理

Vue在patch中key用于判断这个节点是否需要进行复用

没有key会导致更新时出现问题

尽量不要使用索引作为key，当item进行添加时，可能会因为索引绑定元素全部变得，导致无法复用

key的设置，推荐与值有关的唯一值，组件可以用_uid作为唯一

## 17 组件的特点

1. 提高应用开发效率，测试性，重复性
2. 组件化技术： 属性，自定义事件，插槽
3. 降低更新范围，之更新渲染变化的组件
4. 组件的特点： 高内聚，低耦合，单向数据流

## 18 组件渲染流程 TODO

创建组件虚拟节点 => 创建组件的真实节点 => 插入到页面中

##  ast和render的问题 

## 19 Vue组件更新流程

属性更新会触发patchVndoe方法 => 组件虚拟节点会调用prepatch钩子 => 更新属性 => 组件更新

patchVnode => prepatch => updateChildComponent => props[key] = xxx

## 20 Vue异步组件原理

创建组件时会创建一个组件的占位符，当加载完毕后，调用forceUpdate进行更新

重新渲染组件，但是此时直接返回组件而不是占位符

## 21 函数组件的优势及原理

函数式组件特点: 无状态，无生命周期，无this，但是性能高 

正常组件是一个类继承了vue 

函数式组件就是一个普通的函数，没有new，也没有init、prepatch

```js
export function createComponent(
    Ctor: Class < Component > | Function | Object | void,
    data: ? VNodeData,
    context : Component,
    children: ? Array < VNode > ,
    tag ? : string
): VNode | Array < VNode > | void {
    // ...

    // functional component
    if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children)
    }
    // ...
}
```

构造函数产生一个虚拟节点，用于只负责渲染，没有状态

## 22 Vue组件间传值方式

props和$emit 父子组件通信，父通过props传递给子，子通过$emit触发父的事件

$parent，$children 获取当前组件和父组件和当前组件

$attrs 和 $listeners

provide 和 inject

$refs 组件上获取组件实例，放dom上获取dom

eventBus 组件间通信，父通过eventBus触发子的事件

vuex

...

### props实现原理
